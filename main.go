package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"sync"
	"time"

	"gopkg.in/yaml.v2"
)

type UpdateChan struct {
	JustFinished int //The part that we just finished
	ID           int //The ID of whatever processed was finished
}

type PlotInfo struct {
	FileName           string        //The name that is generated by the command line for the file
	ID                 int           //The internal id for the object. Use this to keep track of tasks running etc
	PlotSize           int           //-k Default to 32
	Ram                int           //-b Memory buffer size in MiB, default to 4608. Only allocated to plotting
	FarmerPK           string        //-f The farmer public key, if unassigned, will not be used
	PoolPK             string        //-p Pool public key, if unassigned, will not be used
	Fingerprint        string        //-a Some fingerprint thing, if unassigned, will not be used
	TempDir1           string        //-t The temporrayr directory for
	TempDir2           string        //-2 The temporary directory for
	FinalDir           string        //-d the final directory to place the plot
	NumThreads         int           //-r The number of threads to use, suggested 2-4
	NumBuckets         int           //-u The number of buckets, more buckets -> less ram, more disk writes
	DisableBitfield    bool          //-e Set to true to include -e, and therefore disable bitfield
	StartTime          time.Time     //The time that the operation started
	TotalTime          time.Duration //How long it took to finish the entire process. StartTime + Duration = FinalTime
	StageOneStart      time.Time     //Time that stage 1 started
	StageOneDuration   time.Duration //Duration of stage 1
	StageTwoStart      time.Time     //Time that stage 2 started
	StageTwoDuration   time.Duration //Duration of stage 2
	StageThreeStart    time.Time     //Time that stage 3 started
	StageThreeDuration time.Duration //Duration of stage 3
	StageFourStart     time.Time     //Time that stage 4 started
	StageFourDuration  time.Duration //Duration of stage 4
	stdout             io.ReadCloser
	stderr             *bytes.Buffer
	quit               chan struct{}
	CurrentStage       int    //The stage that the current run is in, will need to pipe this back to the main service
	SimpleTag          string //Just something people can set to keep track of this instace if they want to
	StartAfter         int    //Storing when to start after here for now
	UpdateMessage      chan UpdateChan
}

func main() {
	/* cmd := exec.Command("ping", "127.0.0.1 -n 6 > nul")
	cmd.Start() */
	
	/* pi := make(chan struct{})
	for {
		select {
		case <-channel:
			fmt.Println("Exit Signal")
			cmd.Process.Kill()
			break
		case <- cmd.Wait():
			break
		}
	} */
	/* pi := PlotInfo{}
	pi.PlotSize = 32
	pi.Ram = 3809
	pi.TempDir1 = "Y:/tempplot1"
	pi.TempDir2 = "Y:/tempplot1"
	pi.FinalDir = "Y:/FinalizedPlots"
	pi.NumThreads = 2
	pi.NumBuckets = 110 */
	/* cmd := exec.Command("cmd.exe", []string{"/C","dir", "Y:\\"}...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout

	err := cmd.Run()
	if err != nil{
		panic(err)
	}
	return */

	//PiBuilder("detailedConfig.yaml", true)
	config := LoadExplicitConfig("detailedConfig.yaml")
	ExplicitServiceRunner(config)
}

//Load in our config file
//This will be used to determine chia run locations and such. Work on that later
func init() {

}

type LockedCounter struct {
	count int
	sync.Mutex
}

//Decide when to run a plot
func ExplicitServiceRunner(config ExplicitConfig) {
	updateChan := make(chan UpdateChan, config.MaxRunning)
	//cancelChannel := make(chan struct{})
	currentRunning := LockedCounter{count: 0}
	numFinished := 0
	//Need to remove itself from the currentList
	currentList := make([]*PlotInfo, 0)
	numRam := 0
	//The newest tasks current stage
	latestMinStage := 5
	//Used to determine if we have gone far enough to start our next task
	idOfMostRecentTask := 0

	if len(config.Tasks) == 0 {
		fmt.Println("No tasks to run found")
		return
	}

	taskIndex := -1
	taskIndexNext := 0
	firstRun := true
	readyToQuite := false
	var wg sync.WaitGroup
BreakSpot:
	for {
		select {
		case update := <-updateChan:
			fmt.Printf("%+v \n", update)
			if update.ID == idOfMostRecentTask {
				latestMinStage = update.JustFinished
			}
			if update.JustFinished == 5 {
				currentRunning.Lock()
				currentRunning.count --
				currentRunning.Unlock()
				numFinished++
				//wg.Done()
				fmt.Println("WRITING DONE")
				if readyToQuite && currentRunning.count == 0{
					break BreakSpot
				}
			}
		default:
			if currentRunning.count < config.MaxRunning && !readyToQuite {
				waitStage := config.Tasks[taskIndexNext].StartAfter
				if firstRun {
					waitStage = 0
					firstRun = false
				}
				//And the next plot is okay with running
				if waitStage <= latestMinStage {
					taskIndex = taskIndexNext
					fmt.Println("Starting a new plot")
					fmt.Println(config.Tasks[taskIndex])
					temp := createPi(config.Tasks[taskIndex], numRam, updateChan)
					currentList = append(currentList, temp)
					wg.Add(1)
					go RunAndReceiveData(temp, &wg)
					currentRunning.Lock()
					currentRunning.count += 1
					currentRunning.Unlock()
					numRam += 1
					latestMinStage = 0
					//Woah wouldnt it be cool to use rbanchless herer
					fmt.Println(taskIndexNext)
					fmt.Println(len(config.Tasks))
					if taskIndexNext == len(config.Tasks)-1 {
						//Will have to check something about loop here i believe
						if !config.Loop {
							fmt.Println("here")
							//If we do not want to loop, and this is the last process, then once all the processes are done, we can quite
							readyToQuite = true
							//break BreakSpot

						} else {
							fmt.Println("loop")
							taskIndexNext = 0
						}

					} else {
						taskIndexNext++
					}
				}
			}
		}
	}

	fmt.Println("Before wg")
	wg.Wait()

}

func createPi(con Tasks, id int, updateChan chan UpdateChan) (pi *PlotInfo) {
	var piHere PlotInfo
	piHere.ID = id
	piHere.PlotSize = con.PlotSize
	piHere.Ram = con.Ram
	piHere.TempDir1 = con.TempDir1
	piHere.TempDir2 = con.TempDir2
	piHere.FinalDir = con.FinalDir
	piHere.NumThreads = con.NumThreads
	piHere.NumBuckets = con.NumBuckets
	piHere.DisableBitfield = con.DisableBitfield
	piHere.StartAfter = con.StartAfter
	piHere.CurrentStage = 0
	piHere.UpdateMessage = updateChan
	pi = &piHere
	return pi
}

func LoadExplicitConfig(filePath string) (config ExplicitConfig) {
	configFile, err := os.Open(filePath)
	// if we os.Open returns an error then handle it
	if err != nil {
		panic(err)
	}
	fmt.Println("Opened " + filePath)
	// defer the closing of our jsonFile so that we can parse it later on
	defer configFile.Close()
	decoder := yaml.NewDecoder(configFile)
	err = decoder.Decode(&config)
	if err != nil {
		panic(err)
	}
	return config
}

func RunAndReceiveData(pi *PlotInfo, wg *sync.WaitGroup) {
	//Going to make an array of all the arguments we will be using
	arguments := make([]string, 0)
	arguments = append(arguments, "plots")
	arguments = append(arguments, "create")
	arguments = append(arguments, fmt.Sprintf("-k %d", pi.PlotSize))
	arguments = append(arguments, fmt.Sprintf("-b %d", pi.Ram))
	//arguments = append(arguments, fmt.Sprintf("-t %s", pi.TempDir1))
	arguments = append(arguments, "-t")
	arguments = append(arguments, pi.TempDir1)
	/* arguments = append(arguments, fmt.Sprintf("-2 %s", pi.TempDir2)) */
	arguments = append(arguments, "-2")
	arguments = append(arguments, pi.TempDir2)
	/* arguments = append(arguments, fmt.Sprintf("-d %s", pi.FinalDir)) */
	arguments = append(arguments, "-d")
	arguments = append(arguments, pi.FinalDir)
	arguments = append(arguments, fmt.Sprintf("-r %d", pi.NumThreads))
	arguments = append(arguments, fmt.Sprintf("-u %d", pi.NumBuckets))
	if pi.DisableBitfield {
		arguments = append(arguments, fmt.Sprintf("-e"))
	}

	//CHANGE: Only for testing
	//arguments = append(arguments, "--override-k")

	//Just some test
	/* arguments = make([]string, 0)
	arguments = append(arguments, "farm", "summary") */

	pi.StartTime = time.Now()
	pi.quit = make(chan struct{})
	fmt.Println(arguments)
	cmd := exec.Command("chia", arguments...)
	//pi.stdout = new(bytes.Buffer)
	pi.stderr = new(bytes.Buffer)
	//cmd.Stdout = pi.stdout
	var err error
	pi.stdout, err = cmd.StdoutPipe()
	if err != nil {
		panic(err)
	}
	//cmd.Stderr = os.Stderr
	go pi.HandleOutput()
	fmt.Println("Starting process at " + pi.StartTime.Format(time.Stamp))

	//We will loop on a signal here
	err = cmd.Start()
	if err != nil {
		panic(err)
	}
	/* go func (){

	}
	cmd.Process.Kill() */
	
	
	fmt.Println("Sending quit message")
	fmt.Printf("%+v", pi)
	close(pi.quit)
	pi.TotalTime = time.Since(pi.StartTime)
	pi.UpdateMessage <- UpdateChan{JustFinished: 5, ID: pi.ID}
	wg.Done()
}

//Handles the output of cmd and processes it. Will update time staging etc
func (pi *PlotInfo) HandleOutput() {
	scanner := bufio.NewScanner(pi.stdout)
	startPhase := regexp.MustCompile(`^Starting phase (\d)`)
	endPhase := regexp.MustCompile(`^Time for phase (\d)`)
	layout := "03_04PM-Jan-02-2006"
	logFile, err := os.Create(strconv.Itoa(pi.ID) + "--" + pi.StartTime.Format(layout) + ".txt")
	hasFailedWriting := false
	if err != nil {
		fmt.Println("Couldnt create a log file, continuing with operations anyway")
		hasFailedWriting = true
	}
	defer logFile.Close()

	/* errScan := bufio.NewScanner(pi.stderr) */
HERE:
	for {
		select {
		case <-pi.quit:
			fmt.Println("Done Logging")
			break HERE
		default:
			//Do our looped action
			if scanner.Scan() {
				//unsure if I want to put scanner.scan into a for as suggested in examples
				line := scanner.Text()
				//fmt.Println(line)
				if !hasFailedWriting {
					_, err = logFile.WriteString(line + "\n")
					if err != nil {
						fmt.Println("Problem with writing to file, future errors will be quited")
						hasFailedWriting = true
					}
				}

				if match := startPhase.FindStringSubmatch(line); len(match) == 2 {
					switch match[1] {
					case "1":
						fmt.Println("starge one start")
						pi.StageOneStart = time.Now()
						pi.CurrentStage = 1
						break
					case "2":
						fmt.Println("starge 2 start")
						pi.StageTwoStart = time.Now()
						pi.CurrentStage = 2
						break
					case "3":
						fmt.Println("starge3 start")
						pi.StageThreeStart = time.Now()
						pi.CurrentStage = 3
						break
					case "4":
						fmt.Println("starge 4 start")
						pi.StageFourStart = time.Now()
						pi.CurrentStage = 4
						break
					}
				} else if match := endPhase.FindStringSubmatch(line); len(match) == 2 {
					switch match[1] {
					case "1":
						pi.StageOneDuration = time.Since(pi.StageOneStart)
						pi.UpdateMessage <- UpdateChan{JustFinished: 1, ID: pi.ID}
						break
					case "2":
						pi.StageTwoDuration = time.Since(pi.StageTwoStart)
						pi.UpdateMessage <- UpdateChan{JustFinished: 2, ID: pi.ID}
						break
					case "3":
						pi.StageThreeDuration = time.Since(pi.StageThreeStart)
						pi.UpdateMessage <- UpdateChan{JustFinished: 3, ID: pi.ID}
						break
					case "4":
						pi.StageFourDuration = time.Since(pi.StageFourStart)
						//Setting stage to 5 here, as the plotter doesn't give the standard message out unfortunately
						//Just the file copy stage
						pi.CurrentStage = 5
						pi.UpdateMessage <- UpdateChan{JustFinished: 4, ID: pi.ID}
						break
					}
				}
			} else if err := scanner.Err(); err != nil {
				fmt.Println(err)
			}

		}
	}
	fmt.Println("actually break out --------------------------------------------------")
}
